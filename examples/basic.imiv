
# [value msgcontents : [fee fee]] #

[unittest,]
fn testReturn := i32 || {
	ret 5;
};

[unittest,]
fn testAdd := i32 || {
	ret [+ 5 -5];
};

[unittest,]
fn testSub := i32 || {
	ret [- 5 -5];
};

[unittest,]
fn testMul := i32 || {
	ret [* 5 -5];
};

[unittest,]
fn testDiv := i32 || {
	ret [* 25 -5];
};

[unittest,]
fn testVariableDeclaration := i32 || {
	const g := i32 {5};
	ret g;
};

[unittest,]
fn testVariableDeclarationSum := i32 || {
	const g := i32 {[+ 1 4]};
	ret g;
};

[unittest,]
fn testVariableDefinition := i32 || {
	const g := i32 {0};
	g := {5};
	ret g;
};

[unittest,]
fn testVariableDefinitionOnOther := i32 || {
	const g := i32 {0};
	const h := i32 {5};
	g := {h};
	ret g;
};

fn testFnParams_Sum := i32 |x : i32, y : i32, z : i32,| {
	ret [+ [+ x y] z];
};

[unittest,]
fn testFnParams := i32 || {
	const g := i32 {0};
	const h := i32 {5};
	ret [testFnParams_Sum g h 10];
};

ret [+ 4 0];

#fn dumb := i32 | x : i32 , y : i32 , | {
#	const g := i32 {-5};
#	ret [+ g g];
#};
#
#fn sum := i32 | x : i32 , y : i32 , | {
#	const g := i32 {5};
#	g := 8;
#	ret [dumb [+ g y] -5];
##	ret [+ g y];
#};
#
#ret [sum -5 -5];

#[sum 9 [+ [+ 8 4] [sum 7 2]]]; # 30

#ret [sum 9 [+ [+ 8 4] [sum 7 2]]]; # 30

#ret [/ -999 [+ 100 [sum -5 [+ 8 [sum 1 3]]]]];

#mapOrigin := Fn : void {
#	|a : int, b : int,|
#
#  ret [+ a b];
#};

#[imiv println msg:{"hello world forever!", "and ever!",}];
#[imiv println]; # empty line
#[imiv println msg:"hello world"];
#
## type unnecessary
#x := "hello world";
#y : String := "hello world";
#
## note that basic units can not be arrays, ei there is no float[] or char[],
## 	instead, they can only be scalars. Since each object is an array of
## 	objects, the correct way to go about this is to wrap these types in a
## 	struct
#
#[imiv println:x];
#
#circle := Struct {
#	radius : float;
#	originX : float;
#	originY : float;
#
#	# remember that what you are getting here is not one instance of circle,
#	# it is a whole array of circles
#	averageDistance := Fn : float {
#		|self : circle|
#
#		ret [
#			reduce
#				array:  [self radius]
#				lambda: [|f0 : float, f1 : float | ret [+ f0 f1]]
#		];
#	};
#
#	moveOrigin := Fn : void {
#		|self : circle, originX : float, originY : float|
#
#		# the for loop will unroll/inline the lambda, if this is not wanted
#		# then you could use `forIndirect` i guess?
#		ret [
#			for
#				array: self
#				lambda: [|inst| [inst originX] :+= originX; [inst originY] :+= originY;]
#		];
#	};
#
#	mapOrigin := Fn : void {
#		|self : circle, mapper : ^|originX:float, originY:float||
#
#		ret [
#			for
#				array: self
#				lambda: [
#					| inst | [mapper originX: [inst originX] originY: [inst originY]]
#				]
#		];
#	};
#
#
#	Color := Struct {
#		red : float;
#		green : float;
#		blue : float;
#	};
#
#	color : Color;
#};
#
#rectangle := Struct {
#	radius : float;
#};
#
#testCircles : circle := [imiv allocate::circle length:50];
#testRects   : rectangle := [imiv allocate::rectangle length:10];
#
#[
#	forWithIterator
#		array: testCircles
#		lambda: [
#			| it : size_t, inst |
#			
#			[inst originX] := [imiv cast from:it to:float];
#			[inst originY] := [imiv cast from:[+ it 20] to:float];
#		]
#];
#
#[imiv printf msg:[testCircle averageDistance]]; # self passed in automatically
#
## or can be static
#[testCircle averageDistance:[allocator withType:circle length:100]];
#
## and can pass anything you want in as long as it satisfies the same kind of
##     kind of restraints used in the function
#[circle averageDistance:testRects];
